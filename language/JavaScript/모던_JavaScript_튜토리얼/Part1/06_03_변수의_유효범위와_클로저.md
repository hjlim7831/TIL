- 자바스크립트 : 함수 지향 언어
  - 개발자에게 많은 자유를 줌
  - 함수 동적 생성 가능
  - 생성한 함수를 다른 함수에 인수로 넘길 수 있음
  - 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있음
- 함수 내부에서 함수 외부에 있는 변수에 접근할 수 있음

  - 함수가 생성된 이후 외부 변수가 변경되면 어떻게 될까?

- 여기선 let, const로 선언한 변수만 다룸
  - var는 오래된 var에서 다룰 것

### 1. 코드 블록

- 코드 블록 `{...}`안에서 선언한 변수는 블록 안에서만 사용할 수 있음

  ```javascript
  {
    // 지역 변수를 선언하고 몇 가지 조작을 했지만 그 결과를 밖에서 볼 수 없습니다.

    let message = "안녕하세요."; // 블록 내에서만 변숫값을 얻을 수 있습니다.

    alert(message); // 안녕하세요.
  }

  alert(message); // ReferenceError: message is not defined
  ```

- 이런 블록은 특정 작업을 수행하는 코드를 한데 묶어 두는 용도로 활용 가능
- 블록 안엔 작업 수행에만 필요한 변수가 들어감

  ```javascript
  {
    // 메시지 출력
    let message = "안녕하세요.";
    alert(message);
  }

  {
    // 또 다른 메시지 출력
    let message = "안녕히 가세요.";
    alert(message);
  }
  ```

- 위 코드에서 블록이 없으면 에러 발생

  - 이미 선언된 변수와 동일한 이름을 가진 변수를 별도의 블록 없이 let으로 선언하면 에러 발생

- if, for, while 등에서도 마찬가지로 `{...}`안에서 선언한 변수는 오직 블록 안에서만 접근 가능
- for 문에서 for 옆 괄호 안에서 선언한 변수도 블록에 속하는 코드로 취급됨

### 2. 중첩 함수

- 함수 내부에서 선언한 함수는 '중첩(nested)' 함수라 부름
- 자바스크립트에선 손쉽게 중첩 함수를 만들 수 있음
- 예시

  ```javascript
  function sayHiBye(firstName, lastName) {
    // 헬퍼(helper) 중첩 함수
    function getFullName() {
      return firstName + " " + lastName;
    }

    alert("Hello, " + getFullName());
    alert("Bye, " + getFullName());
  }
  ```

- 중첩 함수는 새로운 객체의 프로퍼티 형태나 중첩 함수 그 자체로 반환될 수 있음
- 이렇게 반환된 중첩 함수는 어디서든 호출해 사용할 수 있음
- 물론 이때도 외부 변수에 접근할 수 있음

- 예시: `makeCounter`

  ```javascript
  function makeCounter() {
    let count = 0;

    return function () {
      return count++;
    };
  }

  let counter = makeCounter();

  alert(counter()); // 0
  alert(counter()); // 1
  alert(counter()); // 2
  ```

### 3. 렉시컬 환경

#### 단계 1. 변수

- 자바스크립트에선 실행 중인 함수, 코드 블록 `{...}`, 스크립트 전체는 렉시컬 환경(Lexical Environment) 이라 불리는 내부 숨김 연관 객체(internal hidden associated object)를 가짐

- 렉시컬 환경 객체는 두 부분으로 구성됨

  1. 환경 레코드(Environment Record) - 모든 지역 변수를 프로퍼티로 저장하고 있는 객체

  - this 값과 같은 기타 정보도 여기에 저장됨

  2. 외부 렉시컬 환경(Outer Lexical Environment)에 대한 참조 - 외부 코드와 연관됨

- '변수'는 특수 내부 객체인 환경 레코드의 프로퍼티일 뿐
- '변수를 가져오거나 변경'하는 것은 '환경 레코드의 프로퍼티를 가져오거나 변경'함을 의미함

- 스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경(global Lexical Environment)이라고 함
- 네모 상자는 변수가 저장되는 환경 레코드(1)를 나타내고, 네모 상자 옆, 오른쪽을 향하는 화살표는 외부 렉시컬 환경에 대한 참조(2)를 나타냄
- 전역 렉시컬 환경은 외부 참조를 갖지 않으므로, 화살표가 `null`을 가리키는 것을 확인할 수 있음

- 코드가 실행되고 실행 흐름이 이어져 나가면서 렉시컬 환경은 변화함

- 스크립트가 시작되면(execution start) 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라감 (pre-populated)
- let phrase가 나타나기 전에는 해당 변수 사용 불가. 나타난 뒤에는 해당 프로퍼티 값이 undefined가 됨 (아직 값이 할당되지 않았기 때문)

#### 단계 2. 함수 선언문

- 함수도 변수와 마찬가지로 값
- 다만 함수 선언문으로 선언한 함수는 일반 변수와는 달리 **바로 초기화**됨
- 선언되기 전에도 함수를 사용할 수 있는 것이 바로 이 때문

#### 단계 3. 내부와 외부 렉시컬 환경

- 함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어짐
- 이 렉시컬 환경엔 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장됨
- 함수 호출 중엔 호출 중인 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경이 가리키는 외부 렉시컬 환경, 총 2개의 렉시컬 환경을 갖게 됨
- 내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 가짐
- 코드에서 변수에 접근할 땐, 먼저 내부 렉시컬 환경을 검색 범위로 잡고 여기서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장

  - 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복

- 전역 렉시컬 환경에 도달할 때까지 변수를 찾지 못하면, 엄격 모드에선 에러 발생
  - 비 엄격 모드에선 정의되지 않은 변수에 값을 할당하려고 하면 에러가 발생하는 대신 새로운 전역 변수가 만들어짐
  - 이는 하위 호환성을 위해 남아있는 기능

#### 단계 4. 함수를 반환하는 함수

- `makeCounter` 예시

  ```javascript
  function makeCounter() {
    let count = 0;

    return function () {
      return count++;
    };
  }

  let counter = makeCounter();
  ```

- makeCounter()를 호출하면 호출할 때마다 새로운 렉시컬 환경 객체가 만들어지고, 여기에 makeCounter를 실행하는데 필요한 변수들이 저장됨
- maeCounter()가 실행되는 도중엔 본문(return count++)이 한줄짜리인 중첩 함수가 만들어짐
- 현재는 중첩함수가 생성되기만 하고 실행은 되지 않은 상태
- 모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억함
- 함수는 `[[Environment]]`라 불리는 숨김 프로퍼티를 가지는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장됨
- `counter.[[Environment]]`엔 `{count: 0}`이 있는 렉시컬 환경에 대한 참조가 저장됨
- 호출 장소와 상관없이 함수가 자신이 태어난 곳을 기억할 수 있는 건 바로 이 `[[Environment]]` 프로퍼티 덕분
- `counter()`를 호출하면 각 호출마다 새로운 렉시컬 환경이 생성됨
- 이 렉시컬 환경은 `counter.[[Environment]]`에 저장된 렉시컬 환경을 외부 렉시컬 환경으로서 참조함
- 실행 흐름이 중첩 함수의 본문으로 넘어오면 count 변수가 필요한데, 먼저 자체 렉시컬 환경에서 변수를 찾음
- 익명 중첩 함수엔 지역변수가 없기 때문에 이 렉시컬 환경은 비어있는 상황
- 이 counter()의 렉시컬 환경이 참조하는 외부 렉시컬 환경에서 count를 찾아보자 -> count 발견!
- 이제 count++가 실행되면서 count 값이 1 증가해야 하는데, 변수값 갱신은 변수가 저장된 렉시컬 환경에서 이루어짐

### 4. 가비지 컬렉션

- 함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거됨
- 함수와 관련된 변수들은 이때 모두 사라짐
- 함수 호출이 끝나면 관련 변수를 참조할 수 없는 이유가 여기에 있음
- 자바스크립트에서 모든 객체는 도달 가능한 상태일 때만 메모리에 유지됨
- 호출이 끝난 후에도 여전히 도달 가능한 중첩 함수가 있을 수 있음
- 이 중첩함수의 `[[Environment]]` 프로퍼티에 외부 함수 렉시컬 환경에 대한 정보가 저장됨
  - 도달 가능한 상태가 되는 것
- 예시

  ```javascript
  function f() {
    let value = 123;

    return function () {
      alert(value);
    };
  }

  let g = f(); // g.[[Environment]]에 f() 호출 시 만들어지는
  // 렉시컬 환경 정보가 저장됩니다.
  ```

- 이렇게 중첩함수를 사용할 때는 주의할 점이 있음
- `f()`를 여러 번 호출하고 그 결과를 어딘가에 저장하는 경우, 호출 시 만들어지는 각 렉시컬 환경 모두가 메모리에 유지됨
- 아래 예시를 실행하면 3개의 렉시컬 환경이 만들어지는데, 각 렉시컬 환경은 메모리에서 삭제되지 않음

  ```javascript
  function f() {
    let value = Math.random();

    return function () {
      alert(value);
    };
  }

  // 배열 안의 세 함수는 각각 f()를 호출할 때 생성된
  // 렉시컬 환경과 연관 관계를 맺습니다.
  let arr = [f(), f(), f()];
  ```

- 렉시컬 환경 객체는 다른 객체와 마찬가지로 도달할 수 없을 때 메모리에서 삭제됨
- 해당 렉시컬 환경 객체를 참조하는 중첩 함수가 하나라도 있으면 사라지지 않음
- 아래 예시와 같이 중첩 함수가 메모리에서 삭제되고 난 후에야, 이를 감싸는 렉시컬 환경(그리고 그 안의 변수인 `value`)도 메모리에서 제거됨

  ```javascript
  function f() {
    let value = 123;

    return function () {
      alert(value);
    };
  }

  let g = f(); // g가 살아있는 동안엔 연관 렉시컬 환경도 메모리에 살아있습니다.

  g = null; // 도달할 수 없는 상태가 되었으므로 메모리에서 삭제됩니다.
  ```

#### 4.1. 최적화 프로세스

- 함수가 살아있는 동안엔 이론상으론 모든 외부 변수 역시 메모리에 유지됨
- 하지만 실제론 자바스크립트 엔진이 이를 지속해서 최적화함
- 자바스크립트 엔진은 변수 사용을 분석하고 외부 변수가 사용되지 않는다고 판단되면 이를 메모리에서 제거함
- **디버깅 시, 최적화 과정에서 제거됨 변수를 사용할 수 없다는 점이 V8 엔진 (Chrome, Edge, Opera에서 쓰임)의 주요 부작용**
- Chrome 브라우저에서 개발자 도구를 열고 아래의 코드를 실행해보자
- 실행이 일시 중지되었을 때 콘솔에 `alert(value)`를 입력해보자

  ```javascript
  function f() {
    let value = Math.random();

    function g() {
      debugger; // Uncaught ReferenceError: value is not defined가 출력됩니다.
    }

    return g;
  }

  let g = f();
  g();
  ```

- 정의되지 않은 변수는 에러라 출력됨
- 이론상으로는 `value`에 접근할 수 있어야 하지만, 최적화 대상이 되어서 이런 에러가 발생함

- 이 부작용은 버그라기보단 V8만의 특별한 기능이라고 생각하면 될 듯
- 미래에 이 기능은 변경될 수 있음
