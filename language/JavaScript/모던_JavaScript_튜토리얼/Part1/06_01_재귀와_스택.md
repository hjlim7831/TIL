- 재귀 : 큰 목표 작업 하나를 동일하면서 간단한 작업 여러 개로 나눌 수 있을 때 유용한 프로그래밍 패턴
- 목표 작업을 간단한 동작 하나와 목표 작업을 변형한 작업으로 단순화시킬 수 있을 때도 재귀를 사용할 수 있음

- 문제 해결을 하다 보면 함수에서 다른 함수를 호출해야 할 때가 있음
- 함수가 자기 자신을 호출하는 경우를 **재귀**라 함

- 자바스크립트 엔진은 최대 재귀 깊이를 제한함
  - 만개 정도까진 확실히 허용
  - 엔진에 따라 이보다 더 많은 깊이를 허용하는 경우도 있음
  - 대다수의 엔진이 십만까지는 다루지 못함
- 이런 제한을 완화하기 위해 엔진 내부에서 자동으로 'tail calls optimization'라는 최적화를 수행하긴 하지만, 모든 곳에 적용되는 것은 아님. 간단한 경우에만 적용됨
- 재귀 깊이 제한 때문에 재귀를 실제 적용하는데 제약이 있긴 하지만, 재귀는 여전히 광범위하게 사용되고 있음
- 재귀를 사용하면, 간결하고 유지보수가 쉬운 코드를 만들 수 있기 때문

### 2. 실행 컨텍스트와 스택

- 실제 재귀 호출이 어떻게 동작하는지 알아보자
- 이를 위해 함수 내부 동작에 대해 살펴보자

- 실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 실행 컨텍스트(execution context)에 저장됨

- 실행 컨텍스트 : 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조

  - 제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등 상세 내부 정보가 실행 컨텍스트에 저장됨

- 함수 호출 일 회당 정확히 하나의 실행 컨텍스트가 생성됨
- 함수 내부에 중첩 호출이 있을 때는 아래와 같은 절차가 수행됨
  - 현재 함수의 실행이 일시 중지됨
  - 중지된 함수와 연관된 실행 컨텍스트는 실행 컨텍스트 스택(execution context stack)이라는 특별한 자료 구조에 저장됨
  - 중첩 호출이 실행됨
  - 중첩 호출 실행이 끝난 이후, 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시 이어감

#### 2.1. pow(2, 3)

- pow 함수

  ```javascript
  function pow(x, n) {
    if (n == 1) {
      return x;
    } else {
      return x * pow(x, n - 1);
    }
  }

  alert(pow(2, 3));
  ```

- pow(2, 3) 호출 순간 : 실행 컨텍스트엔 변수 `x = 2, n = 3`이 저장됨. 실행 흐름은 함수의 첫 번째 줄에 위치함
- `Context: {x: 2, n: 3, 첫 번째 줄}`
- 함수 실행이 시작되는 순간을 나타낸 것
- `n == 1` 조건을 만족하지 못하므로, 실행 흐름은 if의 두 번째 분기로 넘어감
- `x * pow(x, n - 1)`을 계산하려면 새로운 인수가 들어가는 pow의 서브 호출(subcall), `pow(2, 2)`을 만들어야 함

#### 2.2. pow(2, 2)

- 중첩 호출을 하기 위해, 자바스크립트는 실행 컨텍스트 스택에 현재 실행 컨텍스트를 저장함
- 지금 보고 있는 예시에선 실행 컨텍스트 스택에 동일한 함수 pow를 호출함
- 모든 함수에 대해 아래 프로세스가 똑같이 적용됨

  1. 스택 최상단에 현재 컨텍스트가 '기록'됨
  2. 서브 호출을 위한 새로운 컨텍스트가 만들어짐
  3. 서브 호출이 완료되면, 기존 컨텍스트를 스택에서 꺼내 (pop) 실행을 이어나감

- `pow(2, 2)`가 시작될 때의 실행 컨텍스트

  - `Context: {x: 2, n: 2, 첫 번째 줄}`
  - `Context: {x: 2, n: 3, 다섯 번째 줄}`

- 이전 컨텍스트에 변수 정보, 코드가 일시 중단된 줄에 대한 정보가 저장되어 있기 때문에 서브 호출이 끝났을 때 이전 컨텍스트가 문제 없이 다시 시작됨

#### 2.3. pow(2, 1)

- 동일 과정 반복
- 실행 컨텍스트
  - `Context: {x: 2, n: 1, 첫 번째 줄}`
  - `Context: {x: 2, n: 2, 첫 번째 줄}`
  - `Context: {x: 2, n: 3, 다섯 번째 줄}`

#### 2.4. 실행 종료

- `pow(2, 1)`이 실행될 땐 상황이 달라짐
- 이전과 달리 조건 `n == 1`을 만족시킴
  -> if문의 첫 번째 분기가 실행됨
  ```javascript
  function pow(x, n) {
    if (n == 1) {
      return x;
    } else {
      return x * pow(x, n - 1);
    }
  }
  ```
- 함수 종료. 2가 반환됨
- 이에 상응하는 실행 컨텍스트는 메모리에서 삭제됨
- 스택 맨 위엔 이전의 실행 컨텍스트가 위치하게 됨
- `pow(2, 2)` 실행이 다시 시작되고, 4를 반환
- 다시 이전 컨텍스트가 스택 최상단에 위치하게 됨
- 마지막 실행 컨텍스트까지 처리되면 `pow(2, 3) = 8`이라는 결과가 도출됨

- 재귀 깊이 : 스택에 들어가는 실행 컨텍스트의 최댓값과 동일
- 실행 컨텍스트는 메모리를 차지하므로, 재귀를 사용할 땐 메모리 요구사항에 유의해야 함
- 한편, 반복문 기반 알고리즘을 사용하면 메모리가 절약됨

- 재귀를 이용해 작성한 코드는 반복문을 사용한 코드로 다시 작성 가능
- 반복문을 사용하면 대개 함수 호출의 비용(메모리 사용)이 절약됨
- 하지만 코드를 다시 작성해도 큰 개선이 없는 경우도 있음
  - 조건에 따라 함수가 다른 재귀 서브 호출을 하고, 그 결과를 합칠 경우
  - 분기문이 복잡하게 얽혀있을 때
- 이런 경우에는 최적화가 필요하지 않을 수 있고, 최적화에 드는 노력이 무용지물일 수 있음

- 재귀를 사용하면 코드가 짧아지고 코드 이해도가 높아지며, 유지보수에도 이점이 있음
- 모든 곳에서 메모리 최적화를 신경 써서 코드를 작성해야 하는 것은 아님

### 3. 재귀적 순회

- 재귀는 재귀적 순회(recursive traversal)를 구현할 때 사용하면 좋음
- 예시 : 한 회사의 임직원 정보

  ```javascript
  let company = {
    sales: [
      {
        name: "John",
        salary: 1000,
      },
      {
        name: "Alice",
        salary: 1600,
      },
    ],

    development: {
      sites: [
        {
          name: "Peter",
          salary: 2000,
        },
        {
          name: "Alex",
          salary: 1800,
        },
      ],

      internals: [
        {
          name: "Jack",
          salary: 1300,
        },
      ],
    },
  };
  ```

- 부서에는 여러 명의 직원이 있는데, 이를 배열로 표현할 수 있음
- sales 부서의 John과 Alice라는 2명의 직원을 배열 요소로 표현함
- 부서는 하위 부서를 가질 수 있음
- development 부서는 sites와 internals라는 두 개의 하위 부서를 가짐
- 각 하위부서에도 직원이 있음
- 하위 부서가 커지면 더 작은 단위의 하위 부서(또는 팀)로 쪼개질 가능성도 있음
- 이런 임직원의 급여를 더한 값을 구해야 한다면? 재귀를 사용하는 것이 좋음

  ```javascript
  // 급여 합계를 구해주는 함수
  function sumSalaries(department) {
    if (Array.isArray(department)) {
      // 첫 번째 경우
      return department.reduce((prev, current) => prev + current.salary, 0); // 배열의 요소를 합함
    } else {
      // 두 번째 경우
      let sum = 0;
      for (let subdep of Object.values(department)) {
        sum += sumSalaries(subdep); // 재귀 호출로 각 하위 부서 임직원의 급여 총합을 구함
      }
      return sum;
    }
  }

  alert(sumSalaries(company)); // 7700
  ```
