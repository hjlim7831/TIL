- 자바스크립트엔 글자 하나만 저장할 수 있는 별도의 자료형이 없음
- 텍스트 형식의 데이터는 길이에 상관없이 문자열 형태로 저장됨
- 자바스크립트에서 문자열은 인코딩 방식에 상관없이 항상 UTF-16 형식을 따름

### 1. 따옴표

- 문자열은 작은따옴표나 큰따옴표, 백틱으로 감쌀 수 있음
  ```javascript
  let single = "작은따옴표";
  let double = "큰따옴표";
  let backticks = `백틱`;
  ```
- 작은따옴표와 큰따옴표는 기능상 차이가 없음
- 백틱 : 표현식을 `${...}`로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어주면, 해당 표현식을 문자열 중간에 쉽게 삽입할 수 있음

  - 이런 방식을 탬플릿 리터럴(template literal)이라 부름

  ```javascript
  function sum(a, b) {
    return a + b;
  }

  alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
  ```

- 백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수도 있음

  ```javascript
  let guestList = `손님:
  * John
  * Pete
  * Mary
  `;

  alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 작성
  ```

  - 작은따옴표나 큰따옴표는 이런 식으로 여러 줄짜리 문자열을 만들 수 없음

- 백틱은 템플릿 함수(template function)에서도 사용됨

  ```javascript
  func`string`;
  ```

  - 첫 번째 백틱 바로 앞에 함수 이름(`func`)을 써주면, 이 함수는 백틱 안의 문자열 조각이나 표현식 평가 결과를 인수로 받아 자동으로 호출됨

    - 이런 기능을 '태그드 템플릿(tagged template)'이라 부름
    - 태그드 템플릿을 사용하면 사용자 지정 템플릿에 맞는 문자열을 쉽게 만들 수 있음
    - 태그드 템플릿과 템플릿 함수에 대한 자세한 내용은 MDN [문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals#tagged_templates)에서 확인
    - 예시

      ```javascript
      var person = "Mike";
      var age = 28;

      function myTag(strings, personExp, ageExp) {
        var str0 = strings[0]; // "that "
        var str1 = strings[1]; // " is a "

        // 사실 이 예제의 string에서 표현식이 두 개 삽입되었으므로
        // ${age} 뒤에는 ''인 string이 존재하여
        // 기술적으로 strings 배열의 크기는 3이 됩니다.
        // 하지만 빈 string이므로 무시하겠습니다.
        // var str2 = strings[2];

        var ageStr;
        if (ageExp > 99) {
          ageStr = "centenarian";
        } else {
          ageStr = "youngster";
        }

        // 심지어 이 함수내에서도 template literal을 반환할 수 있습니다.
        return str0 + personExp + str1 + ageStr;
      }

      var output = myTag`that ${person} is a ${age}`;

      console.log(output);
      // that Mike is a youngster
      ```

### 2. 특수 기호

- 줄 바꿈 문자(newline character, `\n`)를 사용하면 작은따옴표나 큰따옴표로도 여러 줄 문자열을 만들 수 있음
  ```javascript
  let guestList = "손님:\n * John\n * Mary";
  alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 작성함
  ```
- 따옴표를 이용해 만든 여러 줄 문자열과 백틱을 이용해 만든 여러 줄 문자열은 표현 방식만 다를 뿐, 차이가 없음

  ```javascript
  let str1 = "Hello\nWorld"; // '줄 바꿈 기호'를 사용해 두 줄짜리 문자열을 만듦

  // 백틱과 일반적인 줄 바꿈 방법(엔터)을 사용해 두 줄짜리 문자열을 만듦
  let str2 = `Hello
  World`;

  alert(str1 == str2); // true
  ```

- 특수 문자 목록
  | 특수 문자 | 설명 |
  | --- | --- |
  | `\n` | 줄 바꿈 |
  | `\r` | 캐리지 리턴(carriage return). Windows에선 캐리지 리턴과 줄 바꿈 특수 문자를 조합(`\r\n`)해 줄을 바꿈. 캐리지 리턴을 단독으로 사용하는 경우는 없음 |
  | `\'`, `\"` | 따옴표 |
  | `\\` | 역슬래시 |
  | `\t` | 탭 |
  | `\b`, `\f`, `\v` | 각각 백스페이스(Backspace), 폼 피드 (Form Feed), 세로 탭(Vertical Tab)을 나타냄. 호환성 유지를 위해 남아있는 기호로, 요즘엔 사용하지 않음 |
  | `\xXX` | 16진수 유니코드 `XX`로 표현한 유니코드 글자 (예시 : 알파벳 `z`는 `\x7A`와 동일) |
  | `\uXXXX` | UTF-16 인코딩 규칙을 사용하는 16진수 코드 XXXX로 표현한 유니코드 기호. XXXX는 반드시 네 개의 16진수로 구성되어야 함 (예시 : `\u00A9`는 저작권 기호의 유니코드) |
  | `\u{X...XXXXXX}` (한 개에서 여섯 개 사이의 16진수 글자) | UTF-32로 표현한 유니코드 기호. 몇몇 특수한 글자는 두 개의 유니코드 기호를 사용해 인코딩되므로, 4바이트를 차지함. 이 방법을 사용하면 긴 코드를 삽입할 수 있음 |

- 모든 특수문자는 '이스케이프 문자(escape character)'라고도 불리는 역슬래시 (backslash character) `\`로 시작함
- 역슬래시는 문자열 내에 따옴표를 넣을 때도 사용할 수 있음
- 예시
  ```javascript
  alert("I'm the Walrus!");
  ```
- 문자열 내의 따옴표엔 `\`를 꼭 붙여줘야 함
- 이렇게 하지 않으면 자바스크립트는 해당 따옴표가 문자열을 닫는 용도로 사용된 것이라 해석하기 때문
- 이스케이프 문자는 문자열을 감쌀 때 사용한 따옴표와 동일한 따옴표에만 붙여주면 됨
- 문자열 내에서 좀 더 우아하게 따옴표를 사용하려면, 아래와 같이 따옴표 대신 백틱으로 문자열을 감싸주면 됨
  ```javascript
  alert(`I'm the Walrus!`); // I'm the Walrus!
  ```
- 역슬래시 `\`는 문자열을 정확하게 읽기 위한 용도로 만들어짐
- `\`는 제 역할이 끝나면 사라짐
- 메모리에 저장되는 문자열엔 `\`가 없음
- 그렇다면 문자열 안에 `\`를 보여줘야 하는 경우엔 어떻게 하면 될까?  
  -> `\\`같이 역슬래시를 두 개 붙이면 됨
  ```javascript
  alert(`역슬래시: \\`); // 역슬래시 : \
  ```

### 3. 문자열의 길이

- `length` 프로퍼티엔 문자열의 길이가 저장됨
  ```javascript
  alert(`My\n`.length); // 3
  ```
- `\n`은 '특수 문자' 하나로 취급되기 때문에, `My\n`의 길이는 3임
- `length`는 프로퍼티임
  - 자바스크립트 이외의 언어를 사용했던 개발자들은 `str.length`가 아닌 `str.length()`로 문자열의 길이를 알아내려고 하는 경우가 있음
  - 하지만 원하는 대로 동작하지 않음
  - `length`는 함수가 아니고, 숫자가 저장되는 프로퍼티라는 점에 주의하기
  - 뒤에 괄호를 붙일 필요가 없음

### 4. 특정 글자에 접근하기

- 문자열 내 특정 위치인 `pos`에 있는 글자에 접근하려면, `[pos]`같이 대괄호를 이용하거나 `str.charAt(pos)`라는 메서드를 호출하면 됨
- 위치는 0부터 시작함

  ```javascript
  let str = `Hello`;

  // 첫 번째 글자
  alert(str[0]); // H
  alert(str.charAt(0)); // H

  // 마지막 글자
  alert(str[str.length - 1]); // o
  ```

- 근래에는 대괄호를 이용하는 방식을 사용함
- `charAt`은 하위 호환성을 위해 남아있는 메서드라고 생각하면 됨
- 두 접근 방식의 차이 : 반환할 글자가 없을 때 드러남

  - `[]` : undefined 반환
  - `charAt` : 빈 문자열 반환

  ```javascript
  let str = `Hello`;

  alert(str[1000]); // undefined
  alert(str.charAt(1000)); // ''
  ```

- `for..of`를 사용하면 문자열을 구성하는 글자를 대상으로 반복 작업을 할 수 있음
  ```javascript
  for (let char of "Hello") {
    alert(char); // H,e,l,l,o
  }
  ```

### 5. 문자열의 불변성

- 문자열은 수정할 수 없음  
  -> 문자열 중간 글자 하나를 바꾸려고 하면 에러 발생

  ```javascript
  let str = "Hi";

  str[0] = "h"; // Error: Cannot assign to read only property '0' of string 'Hi'
  alert(str[0]); // 동작 X
  ```

- 이런 문제를 피하려면, 완전히 새로운 문자열을 하나 만든 다음, 이 문자열을 `str`에 할당하면 됨

  ```javascript
  let str = "Hi";

  str = "h" + str[1]; // 문자열 전체를 교체함

  alert(str); // hi
  ```

- 유사한 예시는 이어지는 절에서 살펴볼 것

### 6. 대소문자 변경하기

- 메서드 toLowerCase()와 toUpperCase()는 대문자를 소문자로, 소문자를 대문자로 변경(케이스 변경)시켜 줌
  ```javascript
  alert("Interface".toUpperCase()); // INTERFACE
  alert("Interface".toLowerCase()); // interface
  ```
- 글자 하나의 케이스만 변경하는 것도 가능
  ```javascript
  alert("Interface"[0].toLowerCase()); // 'i'
  ```

### 7. 부분 문자열 찾기

- 문자열에서 부분 문자열(substring)을 찾는 방법은 여러 가지가 있음

#### 7.1. str.indexOf(substr, pos)

- 이 메서드는 문자열 `str`의 `pos`에서부터 시작해, 부분 문자열 `substr`이 어디에 위치하는지를 찾아줌

  - 원하는 부분 문자열을 찾으면 : 위치 반환
  - 그렇지 않으면 : -1 반환

- 예시

  ```javascript
  let str = "Widget with id";

  alert(str.indexOf("Widget")); // 0
  alert(str.indexOf("widget")); // -1
  alert(str.indexOf("id")); // 1
  ```

- `pos`는 선택적으로 사용할 수 있음
  - 이를 명시하면, 검색이 해당 위치부터 시작함
- 부분 문자열 `"id"`는 위치 1에서 처음 등장하는데, 두 번째 인수에 2를 넘겨 `"id"`가 두 번째로 등장하는 위치가 어디인지 알아보자

  ```javascript
  let str = "Widget with id";

  alert(str.indexOf("id", 2)); // 12
  ```

- 문자열 내 부분 문자열 전체를 대상으로 무언가를 하고 싶다면?

  - 반복문 안에 `indexOf` 사용하기
  - 반복문이 하나씩 돌 때마다 검색 시작 위치가 갱신되면서, `indexOf`가 새롭게 호출됨

    ```javascript
    let str = "As sly as a fox, as strpmg as an ox";

    let target = "as"; // as를 찾아봅시다

    let pos = 0;
    while (true) {
      let foundPos = str.indexOf(target, pos);
      if (foundPos == -1) break;

      alert(`위치: ${foundPos}`);
      pos = foundPos + 1; // 다음 위치를 기준으로 검색 이어감
    }
    ```

- 동일한 알고리즘을 사용해 코드만 짧게 줄이면, 다음과 같음

  ```javascript
  let str = "As sly as a fox, as strong as an ox";

  let target = "as";

  while ((pos = str.indexOf(target, pos + 1)) != -1) {
    alert(`위치: ${pos}`);
  }
  ```

- `str.lastIndexOf(substr, pos)`

  - indexOf와 유사한 기능을 하는 메서드
  - 문자열 끝에서부터 부분 문자열을 찾는다는 점만 다름

- if 문의 조건식에 indexOf를 쓸 때, 주의할 점

  - 아래처럼 쓰면 원하는 결과를 얻을 수 없음

    ```javascript
    let str = "Widget with id";

    if (str.indexOf("Widget")) {
      alert("찾았다!");
    }
    ```

  - -1과 비교해야 함. 위처럼 하면 0을 반환할 때 alert창이 뜨지 않음

#### 7.2. 비트 NOT 연산자를 사용한 기법

- 비트 NOT 연산자 : 피연산자를 32비트 정수로 바꾼 후 (소수부는 모두 버려짐), 모든 비트를 반전함
- 따라서 `n`이 32비트 정수일 때, `~n`은 `-(n+1)`이 됨

- 예시

  ```javascript
  alert(~2); // -3
  alert(~1); // -2
  alert(~0); // -1
  alert(~-1); // 0
  ```

- 부호가 있는 32비트 정수 n중, `~n`을 0으로 만드는 경우는 `n == -1`일 때가 유일함

  ```javascript
  let str = "Widget";

  if (~str.indexOf("Widget")) {
    alert("찾았다!"); // 의도한 대로 동작함
  }
  ```

- 하지만 이렇게 언어 특유의 기능을 사용해 직관적이지 않은 코드를 작성하는 것은 추천하지 않음
- 위와 같은 기법은 오래된 스크립트에서 쉽게 만날 수 있어, 알아둬야 함
  - `if (~str.indexOf(...))` 패턴의 코드를 만나면, '부분 문자열인지 확인'하는 코드라고 기억해두기
- 문자열이 아주 길지 않은 경우에만 ~ 연산자가 의도한대로 작동할 것
  - 아주 큰 숫자에 `~` 연산자를 적용하면, 32비트 정수로 바꾸는 과정에서 잘림 현상이 발생하기 때문
  - 이런 숫자 중 가장 큰 숫자 : `4294967295`

#### 7.3. includes, startsWith, endsWith

- 비교적 근래에 나온 메서드인 `str.includes(substr, pos)`는 `str`에 부분 문자열 `substr`이 있는지에 따라 `true`나 `false`를 반환
- 부분 문자열의 위치 정보는 필요하지 않고, 포함 여부만 알고 싶을 때 적합한 메서드

  ```javascript
  alert("Widget with id".includes(Widget)); // true
  alert("Hello".includes("Bye")); // false
  ```

- `str.includes`에도 `str.indexOf`처럼 두 번째 인수를 넘기면, 해당 위치부터 부분 문자열을 검색함

  ```javascript
  alert("Widget".includes("id")); // true
  alert("Widget".includes("id", 3)); // false, 세 번째 위치 이후엔 "id"가 없습니다.
  ```

- 메서드 `str.startsWith`와 `str.endsWith`는 메서드 이름 그대로 문자열 `str`이 특정 문자열로 시작하는지(start with) 여부와 특정 문자열로 끝나는지(end with) 여부를 확인할 때 사용할 수 있음
  ```javascript
  alert("Widget".startsWith("Wid")); // true
  alert("Widget".endsWith("get")); // true
  ```
