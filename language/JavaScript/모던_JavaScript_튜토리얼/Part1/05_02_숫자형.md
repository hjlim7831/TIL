- 모던 자바스크립트는 숫자를 나타내는 두 가지 자료형을 지원

1. 일반적인 숫자

- '배정밀도 부동소수점 숫자(double precision floating point number)'로 알려진 64비트 형식의 IEEE-754에 저장됨
- 튜토리얼 전체에서 이 형식을 사용하여 숫자를 표현할 예정

2. BigInt

- 임의의 길이를 가진 정수는 BigInt로 나타낼 수 있음
- 일반적인 숫자는 253이상이거나 -253이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어짐
- BigInt는 아주 특별한 경우에만 사용됨

### 1. 숫자를 입력하는 다양한 방법

- 10억을 입력해야 한다면?
  ```javascript
  // 가장 분명한 방법
  let billion = 1_000_000_000;
  ```
  - 이렇게 0을 많이 사용해 숫자를 표현하다보면, 잘못 입력하기 쉬움
- 이런 방법보단 숫자 옆에 `'e'`를 붙이고, 0의 개수를 그 옆에 붙여 표현

  ```javascript
  let billion = 1e9; // 10억

  alert(7.3e9); // 73억
  ```

- `'e'`는 e 왼쪽의 수에 e 오른쪽에 있는 수만큼 10의 거듭제곱을 곱하는 효과가 있음

  ```javascript
  1e3 === 1 * 1_000;
  1.23e6 === 1.23 * 1_000_000;
  ```

- 아주 작은 숫자를 표현할 때에도 사용 가능
  ```javascript
  1e-3 = 1 / 1_000
  1.23e-6 === 1.23 / 1_000_000
  ```

#### 1.1. 16진수, 2진수, 8진수

- 16진수 : 색을 나타내거나 문자를 인코딩할 때 등 다양한 곳에서 두루 쓰임
- 16진수를 짧게 표현하는 방법

  ```javascript
  alert(0xff); // 255
  alert(0xff); // (대소문자 안가림)
  ```

- 2진수와 8진수
  ```javascript
  let a = 0b11111111; // 255의 2진수
  let b = 0o377; // 255의 8진수
  alert(a == b); // true
  ```

### 2. toString(base)

- `num.toString(base)` 메서드는 `base` 진법으로 `num`을 표현한 후, 이를 문자형으로 변환해 반환함

  ```javascript
  let num = 255;

  alert(num.toString(16)); // ff
  alert(num.toString(2)); // 11111111
  ```

- base는 2에서 36까지 쓸 수 있음. 기본값 : 10
- base 별 usecase

  - **base = 16** : 16진수 색. 문자 인코딩 등을 표현할 때 사용
    - 숫자는 `0`부터 `9`, 10 이상의 수는 `A`부터 `F`를 사용해 나타냄
  - **base = 2** : 비트 연산 디버깅에 주로 쓰임. 0 또는 1이 될 수 있음
  - **base = 36** : 사용할 수 있는 base 중 최댓값.
    - `0..9`와 `A..Z`를 사용해 숫자를 표현
    - url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용함
    ```javascript
    alert((123456).toString(36)); // 2n9c
    ```

- 점 2개와 메서드 호출
  - `123456..toString(36)`에 있는 점 2개는 오타가 아님
  - 숫자를 대상으로 메서드 `toString`을 직접 호출하고 싶다면, 숫자 다음에 점 두 개 `..`을 붙여야 함
  - `123456.toString(36)`처럼 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있음
  - 점을 하나 더 추가하면, 자바스크립트는 소수부가 없다고 판단하고 함수를 호출함
  - `(123456).toString(36)`도 가능

### 3. 어림수 구하기

- 어림수를 구하는 것(rounding)은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나
- 어림수 관련 내장 함수 몇 가지

  - `Math.floor` : 소수점 첫째 자리에서 내림(버림)
  - `Math.ceil` : 소수점 첫째 자리에서 올림
  - `Math.round` : 소수점 첫째 자리에서 반올림
  - `Math.trunc` : 소수부를 무시 (IE에선 지원 X)

- 소수점 n번째 수를 기준으로 어림수를 구하고 싶다면?

1. 곱하기와 나누기

```javascript
let num = 1.23456;

alert(Math.floor(num * 100) / 100);
```

2. 소수점 n번째 수까지의 어림수를 구한 후, 이를 문자형으로 반환해주는 메서드인 toFixed(n)을 사용

```javascript
let num = 12.34;
alert(num.toFixed(1)); // 12.3

num = 12.36;
alert(num.toFixed(1)); // 12.4
```

- `toFixed`는 `Math.round`와 유사하게 가장 가까운 값으로 올림 혹은 버림해줌
- 주의점 : 이 메서드의 반환값은 문자열
- 소수부의 길이가 인수보다 작으면 끝에 0이 추가됨
- NOTE : `+num.toFixed(5)`처럼 단항 덧셈 연산자를 앞에 붙이거나, `Number()`를 호출하면 문자형의 숫자를 숫자형으로 변환할 수 있음

### 4. 부정확한 계산

- 숫자는 내부적으로 64비트 형식으로 표현됨
- 숫자를 저장하려면, 정확히 64비트가 필요함
- 64비트는 아래와 같이 사용됨
  - 52비트 : 숫자 저장
  - 11비트 : 소수점 위치
  - 1비트 : 부호
- 숫자가 너무 커지면 64비트 공간이 넘쳐, Infinity로 처리됨

  ```javascript
  alert(1e500); // Infinity
  ```

- 정밀도 손실 현상(loss of precision)도 있음

  ```javascript
  alert(0.1 + 0.2 == 0.3); // false

  alert(0.1 + 0.2); // 0.30000000000000004
  ```

- 숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장됨
- 10진법을 이용하면 쉽게 표현할 수 있는 0.1, 0.2 같은 분수는 이진법으로 표현하면 무한 소수가 됨
- IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결
- 반올림 규칙을 적용하면 발생하는 '작은 정밀도 손실'을 우리가 볼 수는 없지만, 실제로 손실은 발생
- 아래와 같이 코드를 작성하면, 정밀도 손실을 눈으로 확인할 수 있음

  ```javascript
  alert((0.1).toFixed(20)); // 0.10000000000000000555
  ```

- 해결 방법?

  - toFixed(n) 메서드를 사용해 어림수 만드는 방법이 가장 신뢰할만한 방법
    - toFixed는 항상 문자열을 반환한다는 점에 유의하기
  - 숫자에 임시로 100을 곱해 정수로 바꾸고, 다시 100으로 나누는 것도 하나의 방법
    - 마지막에 나눗셈이 들어가기 때문에, 소수가 다시 등장할 수 있다는 단점 존재
    - 오류를 줄여주긴 함

- 자바스크립트 내부에서 숫자를 표현하는 방식 때문에, `0`과 `-0`이라는 두 종류의 0이 존재함
  - 대부분의 연산은 `0`과 `-0`을 동일하게 취급하기 때문에, 두 0의 차이는 두드러지지 않는 편

### 5. isNaN과 isFinite

- 두 특수 숫자값
  - `Infinity`, `-Infinity` : 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
  - `NaN` : 에러를 나타내는 값
- 두 특수 숫자는 `숫자형`에 속하지만, `정상적인` 숫자는 아님  
  -> 정상적인 숫자와 구분하기 위한 특별한 함수가 존재함

- `isNaN(value)` : 인수를 숫자로 변환한 다음, `NaN`인지 테스트

  ```javascript
  alert(isNaN(NaN)); // true
  alert(isNaN("str")); // true
  ```

  - `=== NaN` 비교를 하면 안되나?  
    -> 안됨. `NaN`은 자기 자신을 포함해 그 어떤 값과도 같지 않음

  ```javascript
  alert(NaN === NaN); // false
  ```

- `isFinite(value)` : 인수를 숫자로 변환하고 변환한 숫자가 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우, `true`를 반환

  ```javascript
  alert(isFinite("15")); // true
  alert(isFinite("str")); // false
  alert(isFinite(Infinity)); // false
  ```

  - 문자열이 일바 숫자인지 검증하는 데 사용되곤 함
  - 빈 문자열, 공백만 있는 문자열은 `isFinite`를 포함한 모든 숫자 관련 내장 함수에서 `0`으로 취급된다는 점에 유의하기

- NOTE : `Object.is`와 비교하기

  - `Object.is`는 `===`처럼 값을 비교할 때 사용하는 특별한 내장 메서드
  - 아래와 같은 두 가지 에지 케이스에선 `===`보다 좀 더 신뢰할만한 결과를 보여줌

  1. `NaN`을 대상으로 비교할 때 : `Object.is(NaN, NaN) === true` 임
  2. `0`과 `-0`이 다르게 취급되어야 할 때 : `Object.is(0, -0) === false`임

  - 숫자를 나타내는 비트가 모두 0이더라도, 부호를 나타내는 비트는 다름
  - `0`과 `-0`은 사실 다른 값이긴 함

  - 이 두 에지 케이스를 제외하곤, `Object.is(a, b)`와 `a === b`의 결과는 같음
  - 이런 식의 비교는 자바스크립트 명세서에서 종종 찾아볼 수 있음
  - 내부 알고리즘에서 두 값을 비교해야 하는데, 비교 결과가 정확해야 하는 경우 `Object.is`를 사용

### 6. parseInt와 parseFloat

- 단항 덧셈 연산자 `+` 또는 `Number()`를 사용해 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격함
- 피연산자가 숫자가 아니면 형 변환이 실패함
  ```javascript
  alert(+"100px"); // NaN
  ```
- 엄격한 규칙이 적용되지 않는 유일한 예외 : 문자열의 처음 또는 끝에 공백이 있어 공백을 무시할 때
- 실무에선 CSS 등에서 `'100px'`, `'12pt'`와 같이 숫자와 단위를 함께 쓰는 경우가 흔함
- 대다수 국가에서 '19€'처럼 금액 뒤에 통화 기호를 붙여 표시하기도 함
  - 숫자만 추출하는 방법이 필요해보임
- 내장 함수 `parseInt`와 `parseFloat`는 이런 경우를 위해 만들어짐
- 두 함수는 불가능할 때까지 문자열에서 숫자를 '읽음'
- 숫자를 읽는 도중 오류가 발생하면, 이미 수집된 숫자를 반환
  - `parseInt` : 정수
  - `parseFloat` : 부동 소수점 숫자
- 예시

  ```javascript
  alert(parseInt("100px")); // 100
  alert(parseFloat("12.5em")); // 12.5

  alert(parseInt("12.3")); // 12, 정수 부분만 반환됩니다.
  alert(parseFloat("12.3.4")); // 12.3, 두 번째 점에서 숫자 읽기를 멈춥니다.
  alert(parseInt("a123")); // NaN
  ```

- parseInt(str, radix)의 두 번째 인수
  - `parseInt()`의 두번째 매개 변수는 선택적으로 사용할 수 있음
  - radix는 원하는 진수를 지정해줄 때 사용
  - 따라서 parseInt를 사용하면 16진수 문자열, 2진수 문자열 등을 파싱할 수 있음
    ```javascript
    alert(parseInt("0xff", 16)); // 255
    alert(parseInt("ff", 16)); // 255, 0x가 없어도 동작함
    alert(parseInt("2n9c", 36)); // 123456
    ```

### 7. 기타 수학 함수

- `Math.random()` : 0과 1 사이의 난수 반환
  ```javascript
  alert(Math.random()); // 0.1234567894322
  alert(Math.random()); // 0.6533123321453
  ```
- `Math.max(a, b, c...)` / `Math.min(a, b, c...)` : 인수 중 최대/최솟값 반환

  ```javascript
  alert(Math.max(3, 5, -10, 0, 1)); // 5
  alert(Math.min(1, 2)); // 1
  ```

- `Math.pow(n, power)` : n을 power번 거듭제곱한 값을 반환
  ```javascript
  alert(Math.pow(2, 10)); // 2의 10제곱
  ```
