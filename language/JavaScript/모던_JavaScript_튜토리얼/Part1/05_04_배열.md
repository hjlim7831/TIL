- 개발을 진행하다 보면 순서가 있는 컬렉션이 필요할 떄가 생김
  - 사용자나 물건, HTML 요소 목록같이 일목요연하게 순서를 만들어 정렬하고 싶을 경우
- 순서가 있는 컬렉션을 다뤄야 할 때 객체를 사용하면 순서와 관련된 메서드가 없어 그다지 편리하지 않음
- 객체는 태생이 순서를 고려하지 않고 만들어진 자료구조기이 때문에, 객체를 이용하면 새로운 프로퍼티를 기존 프로퍼티 '사이에' 끼워 넣는 것도 불가능
- 이럴 땐 순서가 있는 컬렉션을 저장할 때 쓰는 자료구조인 `배열`을 사용할 수 있음

### 1. 배열 선언

- 아래 두 문법을 사용하면 빈 배열을 만들 수 있음
  ```javascript
  let arr = new Array();
  let arr = [];
  ```
- 대부분 두 번째 방법으로 배열을 선언하는데, 이 때 대괄호 안에 초기 요소를 넣어주는 것도 가능
  ```javascript
  let fruits = ["사과", "오렌지", "자두"];
  ```
- 각 배열 요소엔 0부터 시작하는 숫자(인덱스)가 매겨져 있음
- 이 숫자들은 배열 내 순서를 나타냄
- 배열 내 특정 요소를 얻고 싶다면, 대괄호 안에 순서를 나타내는 숫자인 인덱스를 넣어주면 됨

  ```javascript
  let fruits = ["사과", "오렌지", "자두"];

  alert(fruits[0]); // 사과
  alert(fruits[1]); // 오렌지
  alert(fruits[2]); // 자두
  ```

- 같은 방법으로 요소를 수정할 수 있음
  ```javascript
  fruits[2] = "배"; // 배열이 ["사과", "오렌지", "배"]로 바뀜
  ```
- 새로운 요소를 배열에 추가하는 것도 가능

  ```javascript
  fruits[3] = "레몬"; // 배열이 ["사과", "오렌지", "배", "레몬"]으로 바뀜
  ```

- `length`를 사용하면 배열에 담긴 요소가 몇 개인지 알아낼 수 있음

  ```javascript
  let fruits = ["사과", "오렌지", "자두"];

  alert(fruits.length); // 3s
  ```

- `alert`를 사용해 요소 전체를 출력하는 것도 가능

  ```javascript
  let fruits = ["사과", "오렌지", "자두"];

  alert(fruits); // 사과,오렌지,자두
  ```

- 배열 요소의 자료형엔 제약이 없음

  ```javascript
  // 요소에 여러 가지 자료형이 섞여 있습니다.
  let arr = [
    "사과",
    { name: "이보라" },
    true,
    function () {
      alert("안녕하세요.");
    },
  ];

  // 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력합니다.
  alert(arr[1].name); // 이보라

  // 인덱스가 3인 요소(함수)를 실행합니다.
  arr[3](); // 안녕하세요.
  ```

- trailing 쉼표
  - 배열의 마지막 요소는 객체와 마찬가지로 쉼표로 끝날 수 있음
  ```javascript
  let fruits = ["사과", "오렌지", "자두"];
  ```

### 2. pop, push와 shift, unshift

- **queue** : 배열을 사용해 만들 수 있는 대표적인 자료구조
- 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는 데 사용
- 큐에서 사용하는 주요 연산은 다음과 같음

  - push : 맨 끝에 요소를 추가
  - shift : 제일 앞 요소를 꺼내 제거한 후, 남아있는 요소들을 앞으로 밀어줌. 이렇게 하면 두 번째 요소가 첫 번째 요소가 됨

- 배열엔 두 연산을 가능케 해주는 내장 메서드 `push`와 `pop`이 있음
- 화면에 순차적으로 띄울 메시지를 비축해 놓을 자료 구조를 만들 때 큐를 사용하는 것처럼 큐는 실무에서 상당히 자주 쓰이는 자료구조임
- LIFO(Last-In-First-Out)

- 배열은 **stack**이라 불리는 자료구조를 구현할 때도 쓰임

  - push : 요소를 스택 끝에 집어넣음
  - pop : 스택 끝 요소를 추출

- 스택은 이처럼 '한쪽 끝'에 요소를 더하거나 뺄 수 있게 해주는 자료구조
- 스택은 흔히 카드 한 벌과 비교됨
- 쌓여있는 카드 맨 위에 새로운 카드를 더해주거나 빼는 것처럼, 스택도 '한쪽 끝'에 요소를 집어넣거나 추출할 수 있기 때문
- FIFO(First-In-First-Out, FIFO)

- 이렇게 처음이나 끝에 요소를 더하거나 빼주는 연산을 제공하는 자료구조를 컴퓨터 과학 분야에서는 데큐(deque, Double Ended Queue)라고 부름

  - pop : 배열 끝 요소를 제거하고, 제거한 요소를 반환
  - push : 배열 끝에 요소를 추가
  - shift : 배열 앞 요소를 제거하고, 제거한 요소를 반환
  - unshift : 배열 앞에 요소를 추가

### 3. 배열의 내부 동작 원리

- 배열은 특별한 종류의 객체
- 배열의 요소를 대괄호를 사용해 접근하는 방식(`arr[0]`)은 객체 문법에서 옴
  - 배열은 키가 숫자라는 점만 다름
- 숫자형 키를 사용함으로써 배열은 객체 기본 기능 이외에도 순서가 있는 컬렉션을 제어하게 해주는 특별한 메서드를 제공함
- `length`라는 프로퍼티도 제공
- 하지만 어쨌든 배열의 본질은 **객체**
- 이렇게 배열은 자바스크립트의 일곱 가지 원시 자료형에 해당하지 않고, 원시 자료형이 아닌 객체형에 속하기 때문에 객체처럼 동작함
- 예시

  ```javascript
  let fruits = ["바나나"];

  let arr = fruits; // 참조를 복사함

  alert(arr === fruits);

  arr.push("배");

  alert(fruits); // 바나나, 배
  ```

- 배열을 배열답게 만들어주는 것은 특수 내부 표현방식임
- 자바스크립트 엔진은 아래쪽 그림에서처럼 배열의 요소를 인접한 메모리 공간에 차례로 저장해 연산 속도를 높임
- 이 방법 이외에도 배열 관련 연산을 더 빠르게 해주는 최적화 기법은 다양함
- 그런데 개발자가 배열을 '순서가 있는 자료의 컬렉션'처럼 다루지 않고, 일반 객체처럼 다루면 이런 기법들이 제대로 동작하지 않음

  ```javascript
  let fruits = []; // 빈 배열을 하나 만들기
  fruits[99999] = 5;
  fruits.age = 25;
  ```

- 배열은 객체이므로, 예시처럼 원하는 프로퍼티를 추가해도 문제가 발생하지 않음
- 이렇게 코드를 작성하면, 자바스크립트 엔진이 배열을 일반 객체처럼 다루게 되어 배열을 다룰 때만 적용되는 최적화 기법이 동작하지 않아, 배열 특유의 이점이 사라짐
- 잘못된 방법의 예

  - `arr.test = 5`와 같이 숫자가 아닌 프로퍼티 키로 사용하는 경우
  - `arr[0]`, `arr[1000]`만 추가하고 그 사이에 아무런 요소도 없는 경우
  - `arr[1000]`, `arr[999]` 같이 요소를 역순으로 채우는 경우

- 배열은 *순서가 있는 자료*를 저장하는 용도로 만들어진 특수한 자료구조
- 배열 내장 메서드들은 이런 용도에 맞게 만들어짐
- 자바스크립트 엔진은 이런 특성을 고려해 배열을 신중하게 조정하고, 처리하므로 배열을 사용할 땐 이런 목적에 맞게 사용하기!
- 임의의 키를 사용해야 한다면, 배열보단 일반 객체 `{}`가 적합한 자료구조일 확률이 높음

### 4. 성능

- push와 pop은 빠르지만 shift와 unshift는 느림
  - 맨 앞에 요소를 추가하거나 제거할 경우, 뒤의 요소들을 다 옮겨줘야 함
  - 배열의 크기에 영향을 받음

### 5. 반복문

- for문은 배열을 순회할 때 쓰는 가장 오래된 방법
- 순회시엔 인덱스를 사용

  ```javascript
  let arr = ["사과", "오렌지", "배"];

  for (let i = 0; i < arr.length; i++) {
    alert(arr[i]);
  }
  ```

- 배열에 적용할 수 있는 또 다른 순회 문법으론 `for..of`가 있음

  ```javascript
  let fruits = ["사과", "오렌지", "자두"];

  for (let fruit of fruits) {
    alert(fruit);
  }
  ```

- `for..of`를 사용하면 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있음
- 이 정도 기능이면 원하는 것을 충분히 구현할 수 있고 문법도 짧기 때문에, 배열의 요소를 대상으로 반복 작업을 할 땐 `for..of`를 사용하기

- 배열은 객체형에 속하므로, `for..in`을 사용하는 것도 가능

  ```javascript
  let arr = ["사과", "오렌지", "배"];

  for (let key in arr) {
    alert(arr[key]); // 사과, 오렌지, 배
  }
  ```

- 하지만 `for..in`은 다음과 같은 특징을 가지므로, 배열애 `for..in`을 사용하면 문제가 발생함. 되도록 다른 반복문을 사용하기

  1. `for..in` 반복문은 모든 프로퍼티를 대상으로 순회함. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함됨

  - 브라우저나 기타 호스트 환경에서 쓰이는 객체 중, 배열과 유사한 형태를 보이는 '유사 배열(array-like)' 객체가 있음
  - 유사 배열 객체엔 배열처럼 length 프로퍼티도 있고, 요소마다 인덱스도 붙어 있음
  - 그런데 여기에 더해 유사 배열 객체엔 배열과 달리 키가 숫자형이 아닌 프로퍼티와, 메서드가 있을 수 있음
  - 유사 배열 객체와 `for..in`을 함께 사용하면, 이 모든 것을 대상으로 순회가 일어남
  - 따라서 '필요 없는' 프로퍼티들이 문제를 일으킬 가능성이 생김

  2. `for..in` 반복문은 배열이 아니라 객체와 함께 사용할 때 최적화되어 있어 배열에 사용하면 객체에 사용하는 것 대비 10 ~ 100배 정도 느림

  - `for..in` 반복문의 속도가 대체로 빠른 편이기 때문에, 병목 지점에서만 문제가 되긴 함
  - `for..in` 반복문을 사용할 땐 이런 차이를 알고 적절한 곳에 사용하기
  - 결론 : 배열엔 되도록 `for..in`를 쓰지 말기

### 6. 'length' 프로퍼티

- 배열에 무언가 조작을 가하면 `length` 프로퍼티가 자동으로 갱신됨
- `length` 프로퍼티는 배열 내 요소의 개수가 아니라, **가장 큰 인덱스에 1을 더한 값**
- 따라서 배열에 요소가 하나 있고, 이 요소의 인덱스가 아주 큰 정수라면 배열의 `length` 프로퍼티도 아주 커짐

  ```javascript
  let fruits = [];
  fruits[123] = "사과";

  alert(fruits.length); // 124
  ```

  - 배열을 이렇게 사용하지 않기!

- length 프로퍼티 특징 2 : 쓰기가 가능
- length의 값을 수동으로 증가시키면 아무 일도 일어나지 않음
- 값을 감소시키면 배열이 잘림
- 짧아진 배열은 다시 되돌릴 수 없음

  ```javascript
  let arr = [1, 2, 3, 4, 5];

  arr.length = 2; // 요소 2개만 남기고 잘라봅시다.
  alert(arr); // [1, 2]

  arr.length = 5; // 본래 길이로 되돌려 보자
  alert(arr[3]); // undefined
  ```

- 이런 특징을 이용해 `arr.length = 0;`을 사용해 배열을 비울 수 있음
