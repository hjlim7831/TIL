#### 1. Go 채널
- 채널을 통해 데이터를 주고 받는 통로
- make() 함수를 통해 미리 생성되어야 함
- 채널 연산자 `<-`을 통해 데이터를 보내고 받음
- 흔히 goroutine들 사이 데이터를 주고 받는데 사용됨
- 상대편이 준비될 때까지 채널에서 대기함으로써, 별도의 lock을 걸지 않고 데이터를 동기화하는 데 사용됨
- 채널 생성 시, make() 함수에 어떤 타입의 데이터를 채널에서 주고 받을지를 미리 지정해줘야 함
- 채널로 데이터를 보낼 때 : 채널명 <- 데이터
- 채널로부터 데이터를 받을 때 : <- 채널명
``` go
package main

func main() {
    // 정수형 채널을 생성한다
    ch := make(chan int)

    go func() {
        ch <- 123 // 채널에 123을 보냄
    }()

    var i int
    i = <- ch // 채널로부터 123을 받음
    println(i)
}
```
- Go 채널은 수신자와 송신자가 서로를 기다림
- 이를 이용해 Go 루틴이 끝날 때까지 기다리는 기능을 구현할 수 있음
- 즉, 익명함수를 사용한 Go 루틴에서 어떤 작업이 실행되고 있을 때, 메인루틴은 <-done 에서 계속 수신하며 대기하고 있게 됨
- 익명함수 Go 루틴에서 작업이 끝난 후, done 채널에 true를 보내면 수신자 메인루틴은 이를 받고 프로그램을 끝내게 됨
``` go
package main

import "fmt"

func main() {
    done := make(chan bool)
    go func() {
        for i := 0; i < 10; i++ {
            fmt.Println(i)
        }
        done <- true
    }()

    // 위의 Go루틴이 끝날 때까지 대기
    <-done
}
```

#### 2. Go 채널 버퍼링
- Go 채널은 2가지의 채널이 있음
    1. Unbuffered Channel
    - 이 채널에서는 하나의 수신자가 데이터를 받을 때까지 송신자가 데이터를 보내는 채널에 묶여 있게 됨
    2. Buffered Channel
    - 수신자가 받을 준비가 되어 있지 않을 지라도, 지정된 버퍼만큼 데이터를 보내고 계속 다른 일을 수행할 수 있음
    - make(chan type, N) 함수를 통해 생성됨
    - N에 사용할 버퍼 갯수를 넣음  
    ex) make(chan int, 10) : 10개의 정수형을 갖는 버퍼 채널을 만듦

- 버퍼 채널을 이용하지 않는 경우, 아래와 같은 코드는 에러(fatal error: all goroutines are asleep - deadlock!)를 발생시킴
- 메인루틴에서 채널에 1을 보내면서 상대편 수신자를 기다리고 있는데, 이 채널을 받는 수신자 Go루틴이 없기 때문
``` go
package main

import "fmt"

func main() {
    c := make(chan int)
    c <- 1 // 수신 루틴이 없으므로 데드락
    fmt.Println(<-c) // 코멘트해도 데드락 (별도의 Go루틴이 없기 때문)
}
```
- 하지만 아래와 같이 버퍼채널을 사용하면, 수신자가 당장 없더라도 최대버퍼 수까지 데이터를 보낼 수 있어 에러가 발생하지 않음
``` go
package main

import "fmt"

func main() {
    ch := make(chan int, 1)

    // 수신자가 없더라도 보낼 수 있다.
    ch <- 101
    fmt.Println(<-ch)
}
```